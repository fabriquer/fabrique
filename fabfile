#
# Fabrique build description for Fabrique.
#

print('Configuring Fabrique with arguments:');
print(args);

which = import('which');

debug = args.debug ? false;
filecheck = file(args.filecheck ? which.executable('FileCheck').fullname);
lit = file(args.lit ? which.executable('lit').fullname);
verbose_tests = args.verbose_tests ? false;


#
# Source files that go into Fabrique:
#
cxx_srcs =
	import('bin').sources
	+ import('lib').sources
	+ import('Support').sources
	;

vendor = file('vendor');
antlr = vendor :: 'antlr-cxx-runtime';
grammar = vendor :: 'generated-grammar';

generated_srcs =
	import(antlr.name).sources
	+ import(grammar.name).sources
	;


#
# C++ toolchain and compilation flags:
#
clang = import('share/toolchains/c/clang.fab');

cxx_options = record
{
	debug = debug;

	include_dirs = [srcroot srcroot :: 'include'];

	optlevel = (if debug 0 else 2);

	pic = true;

	standard = 'c++14';

	system_include_dirs = [vendor antlr];

	warnings = [
		# We don't care about C++98 compatibility.
		'no-c++98-compat' 'no-c++98-compat-pedantic'

		# We aren't attempting to preserve an ABI. At least not yet.
		'no-padded'

		# We are OK with C99 variable-length arrays.
		'no-vla' 'no-vla-extension'

		# Ignore a problem with old C++ versions and copy elision.
		'no-return-std-move-in-c++11'

		# Don't warn about unknown warnings. TODO: identify compiler versions?
		'no-unknown-warning-option'
	];
};

cxxflags = clang.gcc.flags(cxx_options);
fab_cxxflags = '-Weverything' :: cxxflags;
gen_cxxflags = '-Wno-deprecated-register' :: cxxflags;

ldflags =
	(if debug [ '-g' '-O0' ] else [ '-O2' ])
	+ (if import('platform').posix ['-rdynamic'] else [])
	;


#
# Object files, shared libraries and fab binary:
#
objects = clang.compile(cxx_srcs, fab_cxxflags)
	+ clang.compile(generated_srcs, gen_cxxflags);

fab = clang.binary(objects, binary = file('fab', subdir = 'bin'), flags = ldflags);

plugins = import('base-plugins',
	cxxflags=fab_cxxflags,
	ldflags=ldflags,
	target_dir=file('lib') :: 'fabrique',
	toolchain = record { compile=clang.compile; library=clang.library; },
);


#
# The "everything" target includes fab, its plugins and its test sources.
#
# This is useful for building all the things and double-checking that all of the test
# sources exist without actually running the tests.
#
everything = [ fab ] + plugins.libs + import('tests/manifest.fab').all_files;


#
# Unless `-D tests=false` is specified explicitly, all tests will be executed whenever
# the fab binary, plugins or test sources have changed.
#
# Allow `-D verbose_tests=true` to enable lit's verbose ("show failure details") mode.
#
test = if (args.tests ? true) {
	lit = import('share/lit.fab',
		filecheck = filecheck,
		lit = lit,
		show_failure_details = verbose_tests
	);

	[ lit.run(fab, file('tests'), file('junit.xml'), dependencies = everything) ]
} else {
	[]
};
