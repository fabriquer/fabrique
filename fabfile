#
# Fabrique build description for Fabrique.
#

print('Configuring Fabrique...');


#
# Source files that go into Fabrique:
#
cxx_srcs =
	import('bin').sources
	+ import('lib').sources
	+ import('Support').sources
	;

generated_srcs =
	import('vendor/antlr-cxx-runtime').sources
	+ import('vendor/generated-grammar').sources
	;


#
# C++ toolchain and compilation flags:
#
clang = import('share/toolchains/c/clang.fab');

debug = args.debug ? true;
vendor_dir = file('vendor');

cxx_options = record
{
	debug = debug;

	include_dirs = [srcroot srcroot :: 'include'];

	optlevel = (if debug 0 else 2);

	pic = true;

	standard = 'c++14';

	system_include_dirs = [vendor_dir vendor_dir::'antlr-cxx-runtime'];

	warnings = [
		# We don't care about C++98 compatibility.
		'no-c++98-compat' 'no-c++98-compat-pedantic'

		# We aren't attempting to preserve an ABI. At least not yet.
		'no-padded'

		# We are OK with C99 variable-length arrays.
		'no-vla' 'no-vla-extension'

		# Ignore a problem with old C++ versions and copy elision.
		'no-return-std-move-in-c++11'

		# Don't warn about unknown warnings. TODO: identify compiler versions?
		'no-unknown-warning-option'
	];
};

common_cxx_flags = clang.gcc.flags(cxx_options);

cxx_flags = common_cxx_flags + ['-Weverything'];
generated_cxx_flags = common_cxx_flags + [ '-Wno-deprecated-register' ];


#
# Linker flags:
#
ldflags =
	(if debug [ '-g' '-O0' ] else [ '-O2' ])
	+ (if import('platform').posix ['-rdynamic'] else [])
	;


#
# Object files, shared libraries and fab binary:
#
objects = clang.compile(cxx_srcs, cxx_flags)
	+ clang.compile(generated_srcs, generated_cxx_flags);

fab = clang.binary(objects, binary = file('fab', subdir = 'bin'), flags = ldflags);

plugins = import('base-plugins',
	cxxflags=cxx_flags,
	ldflags=ldflags,
	target_dir=file('lib') :: 'fabrique',
	toolchain = record { compile=clang.compile; library=clang.library; },
);


#
# The "everything" target includes fab, its plugins and its test sources.
#
# This is useful for building all the things and double-checking that all of the test
# sources exist without actually running the tests.
#
everything = [ fab ] + plugins.libs + import('tests/manifest.fab').all_files;


#
# Unless `-D tests=false` is specified explicitly, all tests will be executed whenever
# the fab binary, plugins or test sources have changed.
#
# Allow `-D verbose_tests=true` to enable lit's verbose ("show failure details") mode.
#
test = if (args.tests ? true) {
	lit = import('share/lit.fab',
		lit = args.lit ? import('which').executable('lit'),
		show_failure_details = args.verbose_tests ? false,
	);

	[ lit.run(fab, file('tests'), file('junit.xml'), dependencies = everything) ]
} else {
	[]
};
