#
# Fabrique build description for Fabrique.
#

# The `pretty` argument controls coloured compiler output and other aesthetic niceness
pretty:bool = args.pretty ? true;

if pretty
{
	print('Configuring Fabrique with arguments:');
	print(args)
}
else   # TODO: maybe we should allow else-less `if` expressions?
{
	[]
};

debug:bool = args.debug ? false;
release:bool = args.release ? not debug;
lto:bool = release or (args.lto ? false);

which = import('which');
filecheck:file = args.filecheck ? which.executable('FileCheck');
lit:file = args.lit ? which.executable('lit');
verbose_tests:bool = args.verbose_tests ? false;


#
# Directories containing vendored (including generated) code:
#
vendor = file('vendor');
antlr = vendor :: 'antlr-cxx-runtime';
grammar = vendor :: 'generated-grammar';


#
# C++ toolchain and compilation flags:
#
clang = import('share/toolchains/c/clang.fab', colour_diagnostics=pretty, lto=lto);

cxx_options = record
{
	debug = debug;

	include_dirs = [srcroot srcroot :: 'include'];

	optlevel = (if debug 0 else 2);

	pic = true;

	standard = 'c++14';

	system_include_dirs = [vendor antlr];

	warnings = [
		# Warn about lots and lots of things.
		'everything'

		# We don't care about C++98 compatibility.
		'no-c++98-compat' 'no-c++98-compat-pedantic'

		# We aren't attempting to preserve an ABI. At least not yet.
		'no-padded'

		# We are OK with C99 variable-length arrays.
		'no-vla' 'no-vla-extension'

		# Ignore a problem with old C++ versions and copy elision.
		'no-return-std-move-in-c++11'

		# Don't warn about unknown warnings. TODO: identify compiler versions?
		'no-unknown-warning-option'
	];
};

binary_options = record
{
	debug = debug;
	dynamic = true;
};


#
# Object files, shared libraries and fab binary:
#

generated_sources =
	import(antlr.name).sources
	+ import(grammar.name).sources
	;

library_objects =
	clang.compile(import('lib').sources, cxx_options)
	+ clang.compile(generated_sources, cxx_options, extra_flags=['-Wno-everything'])
	;

library = clang.library(library_objects, 'fabrique',
	subdir = file('lib'),
	options = record { shared_library = true; });

binary_objects = clang.compile(import('bin').sources, cxx_options);

# Link library objects into `fab` binary statically for three reasons:
#
# 1. it makes for simpler bootstrapping when we don't have to find libraries
#    or require them to be installed in particular places,
# 2. this provides us with the opportunity for link-time optimization and
# 3. the binary is so small as to be almost trivial.
fab = clang.binary(
	objects = binary_objects + library_objects,
	binary = file('fab', subdir = 'bin'),
	options = binary_options);

plugins = import('base-plugins',
	cxx_options=cxx_options,
	target_dir=file('lib') :: 'fabrique',
	toolchain = record { compile=clang.compile; library=clang.library; },
);


#
# The "everything" target includes fab, its plugins and its test sources.
#
# This is useful for building all the things and double-checking that all of the test
# sources exist without actually running the tests.
#
everything = [ fab ] + plugins.libs + import('tests/manifest.fab').all_files;


#
# Unless `-D tests=false` is specified explicitly, all tests will be executed whenever
# the fab binary, plugins or test sources have changed.
#
# Allow `-D verbose_tests=true` to enable lit's verbose ("show failure details") mode.
#
test = if (args.tests ? true) {
	lit = import('share/lit.fab',
		filecheck = filecheck,
		lit = lit,
		show_failure_details = verbose_tests
	);

	[ lit.run(fab, file('tests'), file('junit.xml'), dependencies = everything) ]
} else {
	[]
};
