#
# Fabrique build description for Fabrique.
#

print('Configuring Fabrique vX.Y.Z');  # TODO: Git? shell commands?
print('')


#
# Find toolchain (C++ and shell):
#
platform = import('platform');
cc = import('share/c.fab', platform = platform);
cxx = import('share/cxx.fab', platform = platform);

shell = import('share/shell.fab').shell;


#
# C++ compilation flags:
#
cxxoptions = [ '-std=c++14' ];

debug = args.debug ? true;
dbgflags = if debug [ '-g' '-O0' ] else [ '-O2' ];

includes = foreach dir <- [ srcroot srcroot :: 'include' ] '-I ' + dir.fullname;

# Treat vendor headers as system headers (disable warnings).
vendor_dir = file('vendor');
antlr_dir = vendor_dir :: 'antlr-cxx-runtime';
vendor_flags = cc.system_headers([ vendor_dir antlr_dir ]);

exclude_warnings =
[
	# We really really don't care about C++98 compatibility.
	'c++98-compat' 'c++98-compat-pedantic'

	# We aren't attempting to preserve an ABI. At least not yet.
	'padded'

	# We are OK with C99 variable-length arrays.
	'vla' 'vla-extension'

	# Ignore a problem with old C++ versions and copy elision.
	'return-std-move-in-c++11'

	# Don't warn about unknown warnings. TODO: identify compiler versions?
	'unknown-warning-option'
];

# Use lots and lots of warnings.
warnings = ['-Weverything'] + foreach warn <- exclude_warnings '-Wno-' + warn;

common_cxx_flags = cxxoptions + dbgflags + includes + vendor_flags;
cxx_flags = common_cxx_flags + warnings;
generated_cxx_flags = common_cxx_flags + [ '-Wno-deprecated-register' ];


#
# Linker flags:
#
ldflags =
	(if debug [ '-g' '-O0' ] else [ '-O2' ])
	+ (if platform.posix ['-rdynamic'] else [])
	;


#
# Source files that go into Fabrique:
#
cxx_srcs =
	import('bin').sources
	+ import('lib').sources
	+ import('Support').sources
	;

generated_srcs =
	import('vendor/antlr-cxx-runtime').sources
	+ import('vendor/generated-grammar').sources
	;


#
# Object files, shared libraries and fab binary:
#
objects = cxx.compile(cxx_srcs, cxx_flags)
	+ cxx.compile(generated_srcs, generated_cxx_flags);

fab = cxx.link_executable(objects, executable = file('fab', subdir = 'bin'),
                          flags = ldflags);

print('Binary: ' + fab.fullname);


base_plugins = import('base-plugins',
	cxxflags=cxx_flags,
	ldflags=ldflags,
	toolchain = record { compile=cxx.compile; library=cxx.library; },
);

print('Base plugins: ')
print(foreach plugin <- base_plugins.plugins plugin.name);
print('');

plugins = foreach lib <- base_plugins.libs
	shell.copy(lib, 'lib' :: 'fabrique' :: file(lib.filename))
	;


#
# The "everything" target includes fab, its plugins and its test sources.
#
# This is useful for building all the things and double-checking that all of the test
# sources exist without actually running the tests.
#
everything = [ fab ] + plugins + import('tests/manifest.fab').all_files;


#
# Unless `-D tests=false` is specified explicitly, all tests will be executed whenever
# the fab binary, plugins or test sources have changed.
#
# Allow `-D verbose_tests=true` to enable lit's verbose ("show failure details") mode.
#
test = if (args.tests ? true) {
	lit = import('share/lit.fab',
		lit = args.lit ? import('which').executable('lit'),
		show_failure_details = args.verbose_tests ? false,
	);

	[ lit.run(fab, file('tests'), file('junit.xml'), dependencies = everything) ]
} else {
	[]
};
