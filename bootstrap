#!/usr/bin/env python

import argparse
import itertools
import os
import sys

args = argparse.ArgumentParser()
args.add_argument('builddir', nargs = '?', default = '.')
args.add_argument('--debug', action = 'store_true')
args = args.parse_args()


# First, let's declare what we actually want to build.
cxx_srcs = {
	'AST/': (
		'Action', 'Argument', 'ASTDump', 'BinaryOperation', 'Call',
		'CompoundExpr', 'Conditional',
		'Filename', 'FileList', 'Foreach', 'Function', 'Identifier',
		'List', 'Parameter', 'Scope', 'SymbolReference',
		'UnaryOperation', 'Value',
		'literals',
	),
	'Backend/': (
		'Dot', 'Make', 'Ninja',
	),
	'DAG/': (
		'Build', 'DAG', 'File', 'List', 'Primitive', 'Rule',
		'UndefinedValueException', 'Value',
	),
	'Parsing/': (
		'Lexer', 'Parser',
	),
	'Support/': (
		'Arguments', 'Bytestream', 'ErrorReport', 'Join', 'Location',
		'Printable',
		'exceptions',
	),
	'Types/': (
		'FunctionType', 'Type',
	),
	'': (
		'FabContext',
		'driver',
	),
}

cxx_srcs = list(itertools.chain(*[
	[ '%s%s' % (subdir,base) for base in srcs ]
		for (subdir,srcs) in cxx_srcs.items()
]))


lex = { 'Parsing/fab.l': 'Parsing/fab.lex' }
yacc = { 'Parsing/fab.yy': 'Parsing/fab.yacc' }

src_root = os.path.dirname(os.path.realpath(__file__))

cxxflags = [
	'-I', src_root, '-I', args.builddir,

	# Require C++11.
	'-std=c++11',

	# Use lots and lots of warnings.
	'-Wall',

	# We intentionally hide yyFlexLexer::yylex().
	'-Wno-overloaded-virtual',
]

if args.debug: cxxflags += [ '-g', '-ggdb' ]
else: cxxflags += [ '-D NDEBUG' ]

variables = {
	# tools
	'cc': 'clang',
	'cxx': 'clang++',
	'lex': 'flex',
	'lit': 'llvm-lit',
	'yacc': 'byacc',

	# flags
	'cxxflags': ' '.join(cxxflags),
	'yaccflags': '-d -t',
}



# Then describe the mechanics of how to generate a build file.
import sys

builddir = os.path.realpath(args.builddir)

if not os.path.exists(builddir):
	os.makedirs(builddir)

if not os.path.isdir(builddir):
	sys.write("Build directory '%s' is not a directory" % args.builddir)
	sys.exit(1)

out = open(os.path.join(builddir, 'build.ninja'), 'w')


for var in variables.items():
	out.write('%s = %s\n' % var)

out.write('\n')

test_output = os.path.join(builddir, 'test')
if not os.path.isdir(builddir):
	os.mkdir(test_output)

lit_config = '-sv --param=output-dir=%s --output=%s' % (
	test_output, os.path.join(test_output, 'report.txt'),
)


# Build rules: how we actually build things.
rules = {
	'bin': {
		'command': 'c++ -o $out $in',
		'description': 'Linking $out',
	},

	'cc': {
		'command': '$cc -c $cflags -MMD -MT $out -MF $out.d -o $out $in',
		'description': 'Compiling $in',
		'depfile': '$out.d',
	},

	'cxx': {
		'command': '$cxx -c $cxxflags -MMD -MT $out -MF $out.d -o $out $in',
		'description': 'Compiling $in',
		'depfile': '$out.d',
	},

	'lex': {
		'command': '$lex -c++ --header-file=$header --outfile=$main_out $in',
		'description': 'Processing $in',
	},

	'lit': {
		'command': 'PATH=$path $lit ' + lit_config + ' $in',
		'description': 'Running unit tests',
	},

	'rebuild': {
		'command': 'PATH=$path python $in $args',
		'description': 'Regenerating $out',
	},

	'yacc': {
		'command': '$yacc $yaccflags -o $main_out $in',
		'description': 'Processing $in',
	},
}

for (name, variables) in rules.items():
	out.write('rule %s\n' % name)
	for var in variables.items():
		out.write('  %s = %s\n' % var)
	out.write('\n')


#
# Finally, build statements.
#
bootstrap = sys.argv[0]
args = sys.argv[1:]

# Rebuild the Ninja file:
out.write('''build build.ninja: rebuild %s
  args = %s
  path = %s

''' % (bootstrap, ' '.join(args), os.environ['PATH']))

srcroot = os.path.dirname(os.path.realpath(bootstrap))
path = [ builddir ] + os.environ['PATH'].split(os.pathsep)
path = os.pathsep.join(path)

# Unit tests:
out.write('''build test: lit %s/test | fab
  path = %s

''' % (srcroot, path))


# Main executable
objs = [ '%s.o' % o for o in cxx_srcs + lex.values() + yacc.values() ]

out.write('build fab: bin %s\n\n' % ' '.join(objs))
out.write('default fab\n\n')


# C++ -> object files:
for src in cxx_srcs:
	obj = '%s.o' % src
	src = os.path.join(src_root, '%s.cc' % src)

	if 'Lex' in src or 'driver' in src:
		src += ' | Parsing/fab.yacc.h'

	out.write('build %s: cxx %s\n' % (obj, src))

out.write('\n')

# Lex and yacc:
for (src,target) in lex.items():
	src = os.path.join(src_root, src)
	out.write('build %s.o: cxx %s.cc\n' % (target, target))
	out.write('build %s.h %s.cc: lex %s\n' % (target, target, src))
	out.write('  header = %s.h\n' % target)
	out.write('  main_out = %s.cc\n\n' % target)

for (src,target) in yacc.items():
	src = os.path.join(src_root, src)
	out.write('build %s.o: cxx %s.cc\n' % (target, target))
	out.write('build %s.h %s.cc: yacc %s\n' % (target, target, src))
	out.write('  main_out = %s.cc\n\n' % target)
